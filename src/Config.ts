import { existsSync, mkdirSync, writeFileSync, readFileSync } from "node:fs";
import path from "node:path";
import type { GuardianConfig, ServerConfig } from "./types";

export interface AppConfigData {
  server: ServerConfig;
  guardian: GuardianConfig;
}

export class Config {
  private static instance: Config;
  private data: AppConfigData;
  private configPath: string;
  private configDir: string;

  private constructor() {
    this.configDir = path.resolve(process.cwd(), "config");
    this.configPath = path.resolve(this.configDir, "config.yaml");
    this.data = this.getDefaults();
  }

  public static getInstance(): Config {
    if (!Config.instance) {
      Config.instance = new Config();
    }
    return Config.instance;
  }

  public getDefaults(): AppConfigData {
    const rootDir = process.cwd();
    const dataPath = path.resolve(rootDir, "data");

    return {
      server: {
        jarPath: "server.jar",
        javaBin: "java",
        jvmOptions: ["-Xmx2G", "-Xms2G"],
        programArgs: ["nogui"],
        port: 25565,
        cwd: path.join(dataPath, "server"),
      },
      guardian: {
        autoRestart: true,
        maxRetries: 3,
        retryDelayMs: 5000,
        paths: {
          data: dataPath,
          logs: path.resolve(rootDir, "logs"),
          backups: path.resolve(rootDir, "backups"),
        },
      },
    };
  }

  /**
   * Carga la configuración de forma SÍNCRONA
   */
  public loadSync(): AppConfigData {
    try {
      if (!existsSync(this.configPath)) {
        console.warn("⚠️  Config file not found, creating default structure.");
        this.saveSync();
        return this.data;
      }

      // 1. Leemos el archivo síncronamente
      const content = readFileSync(this.configPath, "utf-8");

      // 2. Parseamos usando Bun.YAML.parse con manejo de errores
      // Usamos "|| {}" para que si el archivo está vacío, no falle el spread
      let parsed = {};
      try {
        parsed = (Bun.YAML.parse(content) || {}) as any;
      } catch (yamlError) {
        console.error("⚠️  YAML parse error, using defaults:", yamlError);
        parsed = {};
      }

      // 3. Merge profundo con validación de tipos implícita
      this.data = {
        ...this.data,
        ...parsed, // Ahora TS sabe que esto es un objeto
        server: {
          ...this.data.server,
          ...(parsed.server || {}), // Spread seguro
        },
        guardian: {
          ...this.data.guardian,
          ...(parsed.guardian || {}), // Spread seguro
          paths: {
            ...this.data.guardian.paths,
            ...(parsed.guardian?.paths || {}), // Spread seguro con optional chaining
          },
        },
      };

      return this.data;
    } catch (e) {
      console.error("❌ Error loading config:", e);
      return this.data;
    }
  }

  /**
   * Guarda la configuración de forma SÍNCRONA
   */
  public saveSync(): void {
    this.ensureDirectoriesSync();

    // Convertir a YAML
    const yamlContent = this.toYAML(this.data);

    writeFileSync(this.configPath, yamlContent, "utf-8");
    console.log(`✅ Configuration saved to ${this.configPath}`);
  }

  /**
   * Crea las carpetas necesarias de forma síncrona
   */
  private ensureDirectoriesSync(): void {
    // Config dir
    if (!existsSync(this.configDir)) {
      mkdirSync(this.configDir, { recursive: true });
    }

    // Server cwd
    if (this.data.server.cwd && !existsSync(this.data.server.cwd)) {
      mkdirSync(this.data.server.cwd, { recursive: true });
    }

    // Guardian paths
    const { data, logs, backups } = this.data.guardian.paths;
    [data, logs, backups].forEach((dir) => {
      if (!existsSync(dir)) {
        mkdirSync(dir, { recursive: true });
      }
    });
  }

  /**
   * Convierte el objeto a YAML string con escapes correctos para Windows
   */
  private toYAML(data: AppConfigData): string {
    // Escapa las barras invertidas para rutas de Windows
    const escapePath = (p: string) => p.replace(/\\/g, "\\\\");

    return `# Guardian Server Configuration
# Generated by Guardian Server Manager

server:
  jarPath: "${data.server.jarPath}"
  javaBin: "${data.server.javaBin}"
  jvmOptions:
${data.server.jvmOptions.map((opt) => `    - "${opt}"`).join("\n")}
  programArgs:
${data.server.programArgs.map((arg) => `    - "${arg}"`).join("\n")}
  port: ${data.server.port}
  cwd: "${escapePath(data.server.cwd)}"

guardian:
  autoRestart: ${data.guardian.autoRestart}
  maxRetries: ${data.guardian.maxRetries}
  retryDelayMs: ${data.guardian.retryDelayMs}
  paths:
    data: "${escapePath(data.guardian.paths.data)}"
    logs: "${escapePath(data.guardian.paths.logs)}"
    backups: "${escapePath(data.guardian.paths.backups)}"
`;
  }

  // Getters
  get server(): ServerConfig {
    return this.data.server;
  }

  get guardian(): GuardianConfig {
    return this.data.guardian;
  }

  get paths() {
    return this.data.guardian.paths;
  }

  // Setters / Updates
  public updateServer(updates: Partial<ServerConfig>): void {
    this.data.server = { ...this.data.server, ...updates };
    this.saveSync();
  }

  public updateGuardian(updates: Partial<GuardianConfig>): void {
    this.data.guardian = { ...this.data.guardian, ...updates };
    this.saveSync();
  }
}
